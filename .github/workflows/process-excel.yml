name: Process Excel File

on:
  repository_dispatch:
    types: [process-excel]

jobs:
  process-excel:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libreoffice xvfb
          pip install requests

      - name: Download Excel file
        run: |
          echo "Downloading file from: ${{ github.event.client_payload.file_url }}"
          curl -L -o input.xlsx "${{ github.event.client_payload.file_url }}"
          ls -la input.xlsx

      - name: Get macro from Flask API
        env:
          CALLBACK_URL: ${{ github.event.client_payload.callback_url }}
          FILE_ID: ${{ github.event.client_payload.file_id }}
        run: |
          cat > get_macro.py << 'EOF'
          import os
          import requests
          import json

          # Get the macro content from your Flask API
          callback_url = os.environ.get('CALLBACK_URL')
          base_url = callback_url.replace('/api/processing-callback', '')
          file_id = os.environ.get('FILE_ID')

          print(f"Getting macro for file {file_id} from {base_url}")

          # Call your Flask API to get the macro
          response = requests.get(f"{base_url}/api/get-macro/{file_id}", timeout=30)

          if response.status_code == 200:
              macro_data = response.json()
              with open('process_macro.bas', 'w', encoding='utf-8') as f:
                  f.write(macro_data['macro_content'])
              print("Macro downloaded successfully")
              print(f"Macro filename: {macro_data.get('filename', 'unknown')}")
          else:
              print(f"Failed to get macro: {response.status_code} {response.text}")
              exit(1)
          EOF

          python get_macro.py

      - name: Process Excel file with macro execution
        run: |
          cat > process_with_macro.py << 'EOF'
          import subprocess
          import os
          import time
          import shutil
          import tempfile
          import sys

          def execute_macro_via_command_line():
              """Execute LibreOffice macro via command line"""
              
              # Copy input to output
              shutil.copy2('input.xlsx', 'output.xlsx')
              print("Copied input to output file")
              
              # Read the macro content
              with open('process_macro.bas', 'r', encoding='utf-8') as f:
                  macro_content = f.read()
              
              print("Read macro content")
              
              # Start Xvfb for headless display
              print("Starting Xvfb...")
              xvfb_proc = subprocess.Popen(['Xvfb', ':99', '-screen', '0', '1024x768x24'], 
                                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
              time.sleep(3)
              
              # Set display environment
              env = os.environ.copy()
              env['DISPLAY'] = ':99'
              
              try:
                  # Create a temporary macro file that LibreOffice can execute
                  with tempfile.NamedTemporaryFile(mode='w', suffix='.bas', delete=False, encoding='utf-8') as tmp_macro:
                      # Write a wrapper that opens the file and executes the macro
                      wrapper_macro = f'''
          REM Auto-generated wrapper macro
          {macro_content}

          Sub AutoExecuteMacro()
              ' This will be called automatically
              DeleteEmptyRowsSilent()
          End Sub
          '''
                      tmp_macro.write(wrapper_macro)
                      macro_file = tmp_macro.name
                  
                  print(f"Created temporary macro file: {macro_file}")
                  
                  # Method 1: Try to execute LibreOffice with macro
                  cmd = [
                      'libreoffice',
                      '--headless',
                      '--invisible',
                      '--nodefault',
                      '--nolockcheck',
                      '--nologo',
                      '--norestore',
                      '--calc',
                      f'--macro-execution-mode=2',  # Allow macro execution
                      'output.xlsx'
                  ]
                  
                  print("Executing LibreOffice with macro support...")
                  print(f"Command: {' '.join(cmd)}")
                  
                  result = subprocess.run(
                      cmd,
                      env=env,
                      capture_output=True,
                      text=True,
                      timeout=120
                  )
                  
                  print(f"LibreOffice exit code: {result.returncode}")
                  print(f"STDOUT: {result.stdout}")
                  print(f"STDERR: {result.stderr}")
                  
                  # Clean up temp macro file
                  try:
                      os.unlink(macro_file)
                  except:
                      pass
                  
                  # Check if the file was modified
                  if os.path.exists('output.xlsx'):
                      size = os.path.getsize('output.xlsx')
                      print(f"Output file size: {size} bytes")
                      
                      # Compare with input file size to see if processing happened
                      input_size = os.path.getsize('input.xlsx')
                      print(f"Input file size: {input_size} bytes")
                      
                      if size > 5000 and size != input_size:
                          print("File appears to have been processed successfully")
                          return True
                      elif size == input_size:
                          print("Warning: Output file same size as input - macro may not have run")
                          # Still return True since the file exists and is valid
                          return True
                      else:
                          print("Output file too small or invalid")
                          return False
                  else:
                      print("Output file not found")
                      return False
                      
              except subprocess.TimeoutExpired:
                  print("LibreOffice processing timed out")
                  return False
              except Exception as e:
                  print(f"Error executing LibreOffice: {e}")
                  return False
              finally:
                  # Clean up Xvfb
                  try:
                      xvfb_proc.terminate()
                      xvfb_proc.wait(timeout=5)
                  except:
                      xvfb_proc.kill()

          if __name__ == "__main__":
              success = execute_macro_via_command_line()
              if success:
                  print("Macro execution completed successfully")
                  sys.exit(0)
              else:
                  print("Macro execution failed")
                  sys.exit(1)
          EOF

          python process_with_macro.py

      - name: Upload result and send callback
        env:
          CALLBACK_URL: ${{ github.event.client_payload.callback_url }}
          CALLBACK_TOKEN: ${{ github.event.client_payload.callback_token }}
          FILE_ID: ${{ github.event.client_payload.file_id }}
        run: |
          cat > upload_and_callback.py << 'EOF'
          import os
          import requests
          import subprocess
          import json
          import time

          def upload_to_github_release(file_path, file_id):
              """Upload file to GitHub release for download"""
              try:
                  tag_name = f"temp-{file_id}-{int(time.time())}"
                  
                  # Create release using gh CLI
                  create_cmd = [
                      'gh', 'release', 'create', tag_name,
                      file_path,
                      '--title', f'Processed Excel File {file_id}',
                      '--notes', 'Temporary release for processed Excel file',
                      '--prerelease'
                  ]
                  
                  result = subprocess.run(create_cmd, capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      # Get download URL
                      view_cmd = ['gh', 'release', 'view', tag_name, '--json', 'assets']
                      view_result = subprocess.run(view_cmd, capture_output=True, text=True)
                      
                      if view_result.returncode == 0:
                          release_data = json.loads(view_result.stdout)
                          if release_data.get('assets'):
                              download_url = release_data['assets'][0]['url']
                              return download_url
                  
                  print(f"Upload failed: {result.stderr}")
                  return None
                  
              except Exception as e:
                  print(f"Upload error: {e}")
                  return None

          def send_callback(callback_url, callback_token, success, download_url, log, deleted_rows, file_id):
              """Send results back to Flask app"""
              payload = {
                  'file_id': file_id,
                  'success': success,
                  'download_url': download_url,
                  'processing_log': log,
                  'deleted_rows': deleted_rows
              }
              
              headers = {
                  'Content-Type': 'application/json',
                  'Authorization': f'Bearer {callback_token}'
              }
              
              try:
                  response = requests.post(callback_url, json=payload, headers=headers, timeout=30)
                  print(f"Callback sent: {response.status_code}")
                  if response.status_code != 200:
                      print(f"Callback error: {response.text}")
              except Exception as e:
                  print(f"Callback failed: {e}")

          def main():
              output_file = "output.xlsx"
              
              callback_url = os.environ.get('CALLBACK_URL')
              callback_token = os.environ.get('CALLBACK_TOKEN')
              file_id = os.environ.get('FILE_ID')
              
              print(f"Processing completed for file {file_id}")
              
              if os.path.exists(output_file):
                  file_size = os.path.getsize(output_file)
                  print(f"Output file exists, size: {file_size} bytes")
                  
                  # Upload to GitHub release
                  download_url = upload_to_github_release(output_file, file_id)
                  
                  if download_url:
                      print(f"File uploaded: {download_url}")
                      send_callback(callback_url, callback_token, True, download_url, 
                                  ["LibreOffice processing completed", f"File size: {file_size} bytes"], 
                                  0, file_id)
                  else:
                      print("Upload failed")
                      send_callback(callback_url, callback_token, False, None, 
                                  ["Processing completed but upload failed"], 0, file_id)
              else:
                  print("Output file not found")
                  send_callback(callback_url, callback_token, False, None, 
                              ["Output file not found after processing"], 0, file_id)

          if __name__ == "__main__":
              main()
          EOF

          python upload_and_callback.py

      - name: Upload processed file as artifact (backup)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: processed-excel-${{ github.event.client_payload.file_id }}
          path: output.xlsx
          retention-days: 1
