name: Process Excel File

on:
  repository_dispatch:
    types: [process-excel]

jobs:
  process-excel:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libreoffice xvfb
          pip install requests

      - name: Download Excel file
        env:
          FILE_URL: ${{ github.event.client_payload.file_url }}
        run: |
          echo "Downloading file from: $FILE_URL"
          curl -L \
            -H "User-Agent: GitHub-Actions-Excel-Processor" \
            -o input.xlsx \
            "$FILE_URL"
          echo "Download completed. File details:"
          ls -la input.xlsx
          file input.xlsx

      - name: Get macro from Flask API
        env:
          CALLBACK_URL: ${{ github.event.client_payload.callback_url }}
          FILE_ID: ${{ github.event.client_payload.file_id }}
        run: |
          cat > get_macro.py << 'EOF'
          import os, requests
          callback_url = os.environ.get('CALLBACK_URL')
          base_url = callback_url.replace('/api/processing-callback', '')
          file_id = os.environ.get('FILE_ID')
          print(f"Getting macro for file {file_id} from {base_url}")
          r = requests.get(f"{base_url}/api/get-macro/{file_id}", timeout=30)
          if r.status_code != 200:
              print(f"Failed to get macro: {r.status_code} {r.text}")
              raise SystemExit(1)
          macro_data = r.json()
          with open('process_macro.bas', 'w', encoding='utf-8') as f:
              f.write(macro_data['macro_content'])
          print("Macro downloaded successfully")
          print(f"Macro filename: {macro_data.get('filename','unknown')}")
          EOF
          python get_macro.py

      - name: Check downloaded file
        run: |
          echo "Checking downloaded file..."
          ls -la input.xlsx
          file input.xlsx
          if [ $(stat -c%s input.xlsx) -lt 1000 ]; then
            echo "ERROR: Downloaded file is too small ($(stat -c%s input.xlsx) bytes)"
            echo "File head:"
            hexdump -C input.xlsx | head -10
            exit 1
          fi

      - name: Process Excel file with macro execution (with fallbacks)
        run: |
          cat > process_with_macro.py << 'EOF'
          import subprocess, os, time, shutil, sys, tempfile, textwrap

          TIMEOUT_M1 = 180   # Method 1 per-attempt timeout
          TIMEOUT_M2 = 180   # Method 2 per-attempt timeout
          TIMEOUT_M3 = 240   # UNO driver timeout

          def kill_soffice():
              # Best-effort cleanup so we never hang the job between attempts
              for patt in ("soffice.bin", "soffice"):
                  try: subprocess.run(["pkill", "-f", patt], check=False)
                  except Exception: pass

          def write_profile_prefs(profile_user_dir: str):
              os.makedirs(profile_user_dir, exist_ok=True)
              xcu = os.path.join(profile_user_dir, "registrymodifications.xcu")
              with open(xcu, "w", encoding="utf-8") as f:
                  f.write("""<?xml version="1.0" encoding="UTF-8"?>
          <oor:items xmlns:oor="http://openoffice.org/2001/registry" xmlns:xs="http://www.w3.org/2001/XMLSchema">
            <item oor:path="/org.openoffice.Office.Common/Misc">
              <prop oor:name="FirstStartWizardCompleted" oor:type="xs:boolean"><value>true</value></prop>
            </item>
            <item oor:path="/org.openoffice.Office.Common/Security/Scripting">
              <prop oor:name="MacroSecurityLevel" oor:type="xs:int"><value>0</value></prop>
            </item>
          </oor:items>
          """)
              print(f"Wrote {xcu}")

          def install_user_macro(macro_dir: str):
              os.makedirs(macro_dir, exist_ok=True)
              module_path = os.path.join(macro_dir, "Module1.bas")
              with open('process_macro.bas', 'r', encoding='utf-8') as f:
                  macro_content = f.read()
              with open(module_path, 'w', encoding='utf-8') as f:
                  f.write(macro_content)
              print(f"Wrote macro to: {module_path}")

              # Register library via script.xlb/dialog.xlb
              basic_root = os.path.dirname(macro_dir)  # .../user/basic
              script_xlb = os.path.join(basic_root, "script.xlb")
              dialog_xlb = os.path.join(basic_root, "dialog.xlb")
              for path, payload in [
                (script_xlb, """<?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE library:library PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "library.dtd">
          <library:library xmlns:library="http://openoffice.org/2000/library" library:name="Standard" library:readonly="false" library:passwordprotected="false">
            <library:element library:name="Module1"/>
          </library:library>
          """),
                (dialog_xlb, """<?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE library:library PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "library.dtd">
          <library:library xmlns:library="http://openoffice.org/2000/library" library:name="Standard" library:readonly="false" library:passwordprotected="false">
          </library:library>
          """)
              ]:
                  os.makedirs(os.path.dirname(path), exist_ok=True)
                  with open(path, 'w', encoding='utf-8') as f:
                      f.write(payload)
                  print(f"Created {path}")

          def start_xvfb():
              print("Starting Xvfb...")
              return subprocess.Popen(["Xvfb", ":99", "-screen", "0", "1024x768x24"],
                                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

          def method_cli(profile_uri, env, output_path, macro_uri, timeout):
              cmd = [
                  "libreoffice",
                  f"-env:UserInstallation={profile_uri}",
                  "--headless", "--nologo", "--norestore", "--nodefault",
                  "--calc",
                  output_path,
                  macro_uri,
              ]
              print("Command:", " ".join(cmd))
              return subprocess.run(cmd, env=env, capture_output=True, text=True, timeout=timeout)

          def method_uno(profile_uri, env, output_path, timeout):
              """Start a listening soffice and invoke macro via UNO (Python-UNO)."""
              accept = "socket,host=127.0.0.1,port=2002;urp;"
              soff = subprocess.Popen([
                  "libreoffice",
                  f"-env:UserInstallation={profile_uri}",
                  "--headless", "--nologo", "--norestore", "--nodefault",
                  f"--accept={accept}"
              ], env=env, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

              uno_script = textwrap.dedent(f"""
                  import sys, time, pathlib, uno
                  from com.sun.star.connection import NoConnectException

                  OUTPUT_URL = pathlib.Path(r{output_path!r}).resolve().as_uri()

                  def connect(max_attempts=60, delay=0.5):
                      local_ctx = uno.getComponentContext()
                      resolver = local_ctx.ServiceManager.createInstanceWithContext(
                          'com.sun.star.bridge.UnoUrlResolver', local_ctx)
                      for _ in range(max_attempts):
                          try:
                              return resolver.resolve(
                                  'uno:socket,host=127.0.0.1,port=2002;urp;StarOffice.ComponentContext'
                              )
                          except NoConnectException:
                              time.sleep(delay)
                      raise RuntimeError('UNO server not ready')

                  def main():
                      ctx = connect()
                      smgr = ctx.ServiceManager
                      desktop = smgr.createInstanceWithContext('com.sun.star.frame.Desktop', ctx)

                      hidden = uno.createUnoStruct('com.sun.star.beans.PropertyValue')
                      hidden.Name = 'Hidden'; hidden.Value = True
                      doc = desktop.loadComponentFromURL(OUTPUT_URL, '_blank', 0, (hidden,))

                      mspi = smgr.createInstanceWithContext(
                          'com.sun.star.script.provider.MasterScriptProviderFactory', ctx)
                      provider = mspi.createScriptProvider('')
                      script = provider.getScript(
                          'vnd.sun.star.script:Standard.Module1.DeleteEmptyRows?language=Basic&location=user'
                      )
                      script.invoke((), (), ())

                      try:
                          doc.store()
                          doc.close(True)
                      except Exception:
                          pass

                      desktop.terminate()

                  if __name__ == '__main__':
                      main()
              """).strip()

              with tempfile.NamedTemporaryFile("w", suffix=".py", delete=False) as tf:
                  tf.write(uno_script)
                  uno_path = tf.name

              try:
                  r = subprocess.run(["python3", uno_path], capture_output=True, text=True, env=env, timeout=timeout)
                  if r.stdout: print(r.stdout)
                  if r.stderr: print(r.stderr)
                  return r.returncode
              finally:
                  try: os.unlink(uno_path)
                  except Exception: pass
                  try: soff.terminate(); soff.wait(timeout=5)
                  except Exception:
                      try: soff.kill()
                      except Exception: pass

          def execute_macro_via_libreoffice():
              # Sanity checks
              if not os.path.exists('input.xlsx'):
                  print("ERROR: input.xlsx not found"); return False
              if os.path.getsize('input.xlsx') < 1000:
                  print("ERROR: Input file too small"); return False
              if not os.path.exists('process_macro.bas'):
                  print("ERROR: process_macro.bas not found"); return False

              # Work on a copy
              shutil.copy2('input.xlsx', 'output.xlsx')
              print("Copied input to output file")

              # Prepare clean temp LO profile + user macro
              profile_dir = os.path.abspath("./lo-profile")
              user_dir    = os.path.join(profile_dir, "user")
              macro_dir   = os.path.join(user_dir, "basic", "Standard")
              write_profile_prefs(user_dir)
              install_user_macro(macro_dir)
              profile_uri = "file://" + profile_dir  # absolute path -> file:///...

              # Xvfb (optional but harmless)
              xvfb = start_xvfb(); time.sleep(2)
              env = os.environ.copy(); env["DISPLAY"] = ":99"

              output_path = os.path.abspath("output.xlsx")

              # --- Method 1 ---
              print("Executing Method 1 (user-profile macro)…")
              try:
                  r1 = method_cli(profile_uri, env, output_path, "macro:///Standard.Module1.DeleteEmptyRows", TIMEOUT_M1)
                  print("Method 1 exit:", r1.returncode)
                  if r1.stdout: print("STDOUT:", r1.stdout)
                  if r1.stderr: print("STDERR:", r1.stderr)
                  if r1.returncode == 0:
                      return _check_output()
              except subprocess.TimeoutExpired:
                  print("Method 1 timed out.")
              finally:
                  kill_soffice()

              # --- Method 2 ---
              print("Method 1 failed, trying Method 2 (file-scoped macro)…")
              try:
                  r2 = method_cli(profile_uri, env, output_path, "macro://./Standard.Module1.DeleteEmptyRows", TIMEOUT_M2)
                  print("Method 2 exit:", r2.returncode)
                  if r2.stdout: print("STDOUT:", r2.stdout)
                  if r2.stderr: print("STDERR:", r2.stderr)
                  if r2.returncode == 0:
                      return _check_output()
              except subprocess.TimeoutExpired:
                  print("Method 2 timed out.")
              finally:
                  kill_soffice()

              # --- Method 3 (UNO) ---
              print("Method 2 failed, trying Method 3 (UNO driver)…")
              try:
                  code = method_uno(profile_uri, env, output_path, TIMEOUT_M3)
                  print("Method 3 exit:", code)
                  if code == 0:
                      return _check_output()
              except subprocess.TimeoutExpired:
                  print("Method 3 timed out.")
              finally:
                  kill_soffice()
                  try: xvfb.terminate(); xvfb.wait(timeout=5)
                  except Exception:
                      try: xvfb.kill()
                      except Exception: pass

              print("✗ All methods failed")
              return False

          def _check_output():
              if os.path.exists("output.xlsx") and os.path.getsize("output.xlsx") > 1000:
                  print(f"Output file size after macro: {os.path.getsize('output.xlsx')} bytes")
                  return True
              print("✗ Output file missing/too small")
              return False

          if __name__ == "__main__":
              print("=" * 60)
              print("Starting Excel file processing with LibreOffice macro")
              print("=" * 60)
              ok = execute_macro_via_libreoffice()
              print("=" * 60)
              if ok:
                  print("✓ Processing completed successfully")
                  print("=" * 60); sys.exit(0)
              else:
                  print("✗ Processing failed")
                  print("=" * 60); sys.exit(1)
          EOF

          python process_with_macro.py

      - name: Upload result and send callback
        env:
          CALLBACK_URL: ${{ github.event.client_payload.callback_url }}
          CALLBACK_TOKEN: ${{ github.event.client_payload.callback_token }}
          FILE_ID: ${{ github.event.client_payload.file_id }}
        run: |
          cat > upload_and_callback.py << 'EOF'
          import os, requests, subprocess, json, time
          def send_callback(callback_url, callback_token, success, download_url, log, deleted_rows, file_id):
              payload = {'file_id': file_id, 'success': success, 'download_url': download_url,
                         'processing_log': log, 'deleted_rows': deleted_rows}
              headers = {'Content-Type': 'application/json', 'Authorization': f'Bearer {callback_token}'}
              try:
                  r = requests.post(callback_url, json=payload, headers=headers, timeout=30)
                  print(f"Callback sent: {r.status_code}")
                  if r.status_code != 200: print(f"Callback error: {r.text}")
              except Exception as e:
                  print(f"Callback failed: {e}")

          def main():
              output_file = "output.xlsx"
              callback_url = os.environ.get('CALLBACK_URL')
              callback_token = os.environ.get('CALLBACK_TOKEN')
              file_id = os.environ.get('FILE_ID')
              print(f"Processing completed for file {file_id}")
              if os.path.exists(output_file):
                  sz = os.path.getsize(output_file)
                  print(f"Output file exists, size: {sz} bytes")
                  # No GH release here yet; just callback success
                  send_callback(callback_url, callback_token, True, None,
                               [f"LibreOffice processing completed", f"File size: {sz} bytes"], 0, file_id)
              else:
                  print("Output file not found")
                  send_callback(callback_url, callback_token, False, None,
                               ["Output file not found after processing"], 0, file_id)
          if __name__ == "__main__":
              main()
          EOF
          python upload_and_callback.py

      - name: Upload processed file as artifact (backup)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: processed-excel-${{ github.event.client_payload.file_id }}
          path: output.xlsx
          retention-days: 1
